!function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=1)}({"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/ContextMenu.js":
/*!****************************************************************************************!*\
  !*** ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/ContextMenu.js ***!
  \****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('/* vim: set ts=2 sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// Ensure this module only gets included once. This is\n// required for user scripts injected into all frames.\n\nwindow.__firefox__.includeOnce("ContextMenu", function () {\n  window.addEventListener("touchstart", function (evt) {\n    var target = evt.target;\n\n    var targetLink = target.closest("a");\n    var targetImage = target.closest("img");\n\n    var data = {};\n\n    if (!targetLink && !targetImage) {\n      // No link or image was tapped, sending empty callback so the ContextMenu will know that it\n      // should not show the menu(only text selection menu if applicable).\n      webkit.messageHandlers.contextMenuMessageHandler.postMessage(data);\n      return;\n    }\n\n    if (targetLink) {\n      data.link = targetLink.href;\n      data.title = targetLink.textContent;\n    }\n\n    if (targetImage) {\n      data.image = targetImage.src;\n      data.title = data.title || targetImage.title;\n      data.alt = targetImage.alt;\n    }\n\n    if (data.link || data.image) {\n      webkit.messageHandlers.contextMenuMessageHandler.postMessage(data);\n    }\n  }, true);\n});\n\n//# sourceURL=webpack:///./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/ContextMenu.js?')},"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/DownloadHelper.js":
/*!*******************************************************************************************!*\
  !*** ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/DownloadHelper.js ***!
  \*******************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('/* vim: set ts=2 sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\nObject.defineProperty(window.__firefox__, "download", {\n  enumerable: false,\n  configurable: false,\n  writable: false,\n  value: function value(url, securityToken) {\n    if (securityToken !== SECURITY_TOKEN) {\n      return;\n    }\n\n    var link = document.createElement("a");\n    link.href = url;\n    link.dispatchEvent(new MouseEvent("click"));\n  }\n});\n\n//# sourceURL=webpack:///./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/DownloadHelper.js?')},"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/FocusHelper.js":
/*!****************************************************************************************!*\
  !*** ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/FocusHelper.js ***!
  \****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('/* vim: set ts=2 sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// Ensure this module only gets included once. This is\n// required for user scripts injected into all frames.\n\nwindow.__firefox__.includeOnce("FocusHelper", function () {\n  var isButton = function isButton(element) {\n    if (element.nodeName !== "INPUT") {\n      return false;\n    }\n\n    var type = element.type.toUpperCase();\n    return type == "BUTTON" || type == "SUBMIT" || type == "FILE";\n  };\n\n  var handler = function handler(event) {\n    var eventType = event.type;\n    var elementType = event.target.nodeName;\n    // We can receive focus and blur events from `a` elements and anything with a `tabindex` attribute.\n    // We should also not fire for buttons..\n    if (elementType === "INPUT" || elementType === "TEXTAREA" || event.target.isContentEditable) {\n      if (!isButton(event.target)) {\n        webkit.messageHandlers.focusHelper.postMessage({\n          eventType: eventType,\n          elementType: elementType\n        });\n      }\n    }\n  };\n\n  var options = {\n    capture: true,\n    passive: true\n  };\n\n  var body = window.document.body;\n  ["focus", "blur"].forEach(function (eventType) {\n    body.addEventListener(eventType, handler, options);\n  });\n});\n\n//# sourceURL=webpack:///./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/FocusHelper.js?')},"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/LoginsHelper.js":
/*!*****************************************************************************************!*\
  !*** ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/LoginsHelper.js ***!
  \*****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('/* vim: set ts=2 sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// Ensure this module only gets included once. This is\n// required for user scripts injected into all frames.\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nwindow.__firefox__.includeOnce("LoginsHelper", function () {\n  var gEnabled = true;\n  var gStoreWhenAutocompleteOff = true;\n  var gAutofillForms = true;\n  var gDebug = false;\n\n  var KEYCODE_ARROW_DOWN = 40;\n\n  function log(pieces) {\n    if (!gDebug) return;\n    alert(pieces);\n  }\n\n  var LoginManagerContent = {\n    _getRandomId: function _getRandomId() {\n      return Math.round(Math.random() * (Number.MAX_VALUE - Number.MIN_VALUE) + Number.MIN_VALUE).toString();\n    },\n\n    _messages: ["RemoteLogins:loginsFound"],\n\n    // Map from form login requests to information about that request.\n    _requests: {},\n\n    _takeRequest: function _takeRequest(msg) {\n      var data = msg;\n      var request = this._requests[data.requestId];\n      this._requests[data.requestId] = undefined;\n      return request;\n    },\n\n    _sendRequest: function _sendRequest(requestData, messageData) {\n      var requestId = this._getRandomId();\n      messageData.requestId = requestId;\n      webkit.messageHandlers.loginsManagerMessageHandler.postMessage(messageData);\n\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        requestData.promise = { resolve: resolve, reject: reject };\n        self._requests[requestId] = requestData;\n      });\n    },\n\n    receiveMessage: function receiveMessage(msg) {\n      var request = this._takeRequest(msg);\n      switch (msg.name) {\n        case "RemoteLogins:loginsFound":\n          {\n            request.promise.resolve({ form: request.form,\n              loginsFound: msg.logins });\n            break;\n          }\n\n        case "RemoteLogins:loginsAutoCompleted":\n          {\n            request.promise.resolve(msg.logins);\n            break;\n          }\n      }\n    },\n\n    _asyncFindLogins: function _asyncFindLogins(form, options) {\n      // XXX - Unlike desktop, I want to avoid doing a lookup if there is no username/password in this form\n      var fields = this._getFormFields(form, false);\n      if (!fields[0] || !fields[1]) {\n        return Promise.reject("No logins found");\n      }\n\n      fields[0].addEventListener("blur", onBlur);\n\n      var formOrigin = LoginUtils._getPasswordOrigin();\n      var actionOrigin = LoginUtils._getActionOrigin(form);\n      if (actionOrigin == null) {\n        return Promise.reject("Action origin is null");\n      }\n\n      // XXX - Allowing the page to set origin information in this message is a security problem. Right now its just ignored...\n      // TODO: We need to designate what type of message we\'re sending here...\n      var requestData = { form: form };\n      var messageData = { type: "request", formOrigin: formOrigin, actionOrigin: actionOrigin };\n      return this._sendRequest(requestData, messageData);\n    },\n\n    loginsFound: function loginsFound(form, _loginsFound) {\n      var autofillForm = gAutofillForms; // && !PrivateBrowsingUtils.isContentWindowPrivate(doc.defaultView);\n      this._fillForm(form, autofillForm, false, false, false, _loginsFound);\n    },\n\n    /*\n     * onUsernameInput\n     *\n     * Listens for DOMAutoComplete and blur events on an input field.\n     */\n    onUsernameInput: function onUsernameInput(event) {\n      if (!gEnabled) return;\n\n      var acInputField = event.target;\n\n      // This is probably a bit over-conservatative.\n      if (!(acInputField.ownerDocument instanceof HTMLDocument)) return;\n\n      if (!this._isUsernameFieldType(acInputField)) return;\n\n      var acForm = acInputField.form;\n      if (!acForm) return;\n\n      // If the username is blank, bail out now -- we don\'t want\n      // fillForm() to try filling in a login without a username\n      // to filter on (bug 471906).\n      if (!acInputField.value) return;\n\n      log("onUsernameInput from", event.type);\n\n      // Make sure the username field fillForm will use is the\n      // same field as the autocomplete was activated on.\n\n      var _getFormFields = this._getFormFields(acForm, false),\n          _getFormFields2 = _slicedToArray(_getFormFields, 3),\n          usernameField = _getFormFields2[0],\n          passwordField = _getFormFields2[1],\n          ignored = _getFormFields2[2];\n\n      if (usernameField == acInputField && passwordField) {\n        var self = this;\n        this._asyncFindLogins(acForm, { showMasterPassword: false }).then(function (res) {\n          self._fillForm(res.form, true, true, true, true, res.loginsFound);\n        }).then(null, log);\n      } else {\n        // Ignore the event, it\'s for some input we don\'t care about.\n      }\n    },\n\n    /*\n     * _getPasswordFields\n     *\n     * Returns an array of password field elements for the specified form.\n     * If no pw fields are found, or if more than 3 are found, then null\n     * is returned.\n     *\n     * skipEmptyFields can be set to ignore password fields with no value.\n     */\n    _getPasswordFields: function _getPasswordFields(form, skipEmptyFields) {\n      // Locate the password fields in the form.\n      var pwFields = [];\n      for (var i = 0; i < form.elements.length; i++) {\n        var element = form.elements[i];\n        if (!(element instanceof HTMLInputElement) || element.type != "password") continue;\n\n        if (skipEmptyFields && !element.value) continue;\n\n        pwFields[pwFields.length] = { index: i,\n          element: element };\n      }\n\n      // If too few or too many fields, bail out.\n      if (pwFields.length == 0) {\n        log("(form ignored -- no password fields.)");\n        return null;\n      } else if (pwFields.length > 3) {\n        log("(form ignored -- too many password fields. [ got ", pwFields.length, "])");\n        return null;\n      }\n      return pwFields;\n    },\n\n    _isUsernameFieldType: function _isUsernameFieldType(element) {\n      if (!(element instanceof HTMLInputElement)) return false;\n\n      var fieldType = element.hasAttribute("type") ? element.getAttribute("type").toLowerCase() : element.type;\n      if (fieldType == "text" || fieldType == "email" || fieldType == "url" || fieldType == "tel" || fieldType == "number") {\n        return true;\n      }\n      return false;\n    },\n\n    /*\n     * _getFormFields\n     *\n     * Returns the username and password fields found in the form.\n     * Can handle complex forms by trying to figure out what the\n     * relevant fields are.\n     *\n     * Returns: [usernameField, newPasswordField, oldPasswordField]\n     *\n     * usernameField may be null.\n     * newPasswordField will always be non-null.\n     * oldPasswordField may be null. If null, newPasswordField is just\n     * "theLoginField". If not null, the form is apparently a\n     * change-password field, with oldPasswordField containing the password\n     * that is being changed.\n     */\n    _getFormFields: function _getFormFields(form, isSubmission) {\n      var usernameField = null;\n\n      // Locate the password field(s) in the form. Up to 3 supported.\n      // If there\'s no password field, there\'s nothing for us to do.\n      var pwFields = this._getPasswordFields(form, isSubmission);\n      if (!pwFields) return [null, null, null];\n\n      // Locate the username field in the form by searching backwards\n      // from the first passwordfield, assume the first text field is the\n      // username. We might not find a username field if the user is\n      // already logged in to the site.\n      for (var i = pwFields[0].index - 1; i >= 0; i--) {\n        var element = form.elements[i];\n        if (this._isUsernameFieldType(element)) {\n          usernameField = element;\n          break;\n        }\n      }\n\n      if (!usernameField) log("(form -- no username field found)");\n\n      // If we\'re not submitting a form (it\'s a page load), there are no\n      // password field values for us to use for identifying fields. So,\n      // just assume the first password field is the one to be filled in.\n      if (!isSubmission || pwFields.length == 1) return [usernameField, pwFields[0].element, null];\n\n      // Try to figure out WTF is in the form based on the password values.\n      var oldPasswordField, newPasswordField;\n      var pw1 = pwFields[0].element.value;\n      var pw2 = pwFields[1].element.value;\n      var pw3 = pwFields[2] ? pwFields[2].element.value : null;\n\n      if (pwFields.length == 3) {\n        // Look for two identical passwords, that\'s the new password\n\n        if (pw1 == pw2 && pw2 == pw3) {\n          // All 3 passwords the same? Weird! Treat as if 1 pw field.\n          newPasswordField = pwFields[0].element;\n          oldPasswordField = null;\n        } else if (pw1 == pw2) {\n          newPasswordField = pwFields[0].element;\n          oldPasswordField = pwFields[2].element;\n        } else if (pw2 == pw3) {\n          oldPasswordField = pwFields[0].element;\n          newPasswordField = pwFields[2].element;\n        } else if (pw1 == pw3) {\n          // A bit odd, but could make sense with the right page layout.\n          newPasswordField = pwFields[0].element;\n          oldPasswordField = pwFields[1].element;\n        } else {\n          // We can\'t tell which of the 3 passwords should be saved.\n          log("(form ignored -- all 3 pw fields differ)");\n          return [null, null, null];\n        }\n      } else {\n        // pwFields.length == 2\n        if (pw1 == pw2) {\n          // Treat as if 1 pw field\n          newPasswordField = pwFields[0].element;\n          oldPasswordField = null;\n        } else {\n          // Just assume that the 2nd password is the new password\n          oldPasswordField = pwFields[0].element;\n          newPasswordField = pwFields[1].element;\n        }\n      }\n\n      return [usernameField, newPasswordField, oldPasswordField];\n    },\n\n    /*\n     * _isAutoCompleteDisabled\n     *\n     * Returns true if the page requests autocomplete be disabled for the\n     * specified form input.\n     */\n    _isAutocompleteDisabled: function _isAutocompleteDisabled(element) {\n      if (element && element.hasAttribute("autocomplete") && element.getAttribute("autocomplete").toLowerCase() == "off") return true;\n\n      return false;\n    },\n\n    /*\n     * _onFormSubmit\n     *\n     * Called by the our observer when notified of a form submission.\n     * [Note that this happens before any DOM onsubmit handlers are invoked.]\n     * Looks for a password change in the submitted form, so we can update\n     * our stored password.\n     */\n    _onFormSubmit: function _onFormSubmit(form) {\n      var doc = form.ownerDocument;\n      var win = doc.defaultView;\n\n      // XXX - We\'ll handle private mode in Swift\n      // if (PrivateBrowsingUtils.isContentWindowPrivate(win)) {\n      // We won\'t do anything in private browsing mode anyway,\n      // so there\'s no need to perform further checks.\n      // log("(form submission ignored in private browsing mode)");\n      // return;\n      // }\n\n      // If password saving is disabled (globally or for host), bail out now.\n      if (!gEnabled) return;\n\n      var hostname = LoginUtils._getPasswordOrigin(doc.documentURI);\n      if (!hostname) {\n        log("(form submission ignored -- invalid hostname)");\n        return;\n      }\n\n      var formSubmitURL = LoginUtils._getActionOrigin(form);\n\n      // Get the appropriate fields from the form.\n      // [usernameField, newPasswordField, oldPasswordField]\n      var fields = this._getFormFields(form, true);\n      var usernameField = fields[0];\n      var newPasswordField = fields[1];\n      var oldPasswordField = fields[2];\n\n      // Need at least 1 valid password field to do anything.\n      if (newPasswordField == null) return;\n\n      // Check for autocomplete=off attribute. We don\'t use it to prevent\n      // autofilling (for existing logins), but won\'t save logins when it\'s\n      // present and the storeWhenAutocompleteOff pref is false.\n      // XXX spin out a bug that we don\'t update timeLastUsed in this case?\n      if ((this._isAutocompleteDisabled(form) || this._isAutocompleteDisabled(usernameField) || this._isAutocompleteDisabled(newPasswordField) || this._isAutocompleteDisabled(oldPasswordField)) && !gStoreWhenAutocompleteOff) {\n        log("(form submission ignored -- autocomplete=off found)");\n        return;\n      }\n\n      // Don\'t try to send DOM nodes over IPC.\n      var mockUsername = usernameField ? { name: usernameField.name,\n        value: usernameField.value } : null;\n      var mockPassword = { name: newPasswordField.name,\n        value: newPasswordField.value };\n      var mockOldPassword = oldPasswordField ? { name: oldPasswordField.name,\n        value: oldPasswordField.value } : null;\n\n      // Make sure to pass the opener\'s top in case it was in a frame.\n      var opener = win.opener ? win.opener.top : null;\n\n      webkit.messageHandlers.loginsManagerMessageHandler.postMessage({\n        type: "submit",\n        hostname: hostname,\n        username: mockUsername.value,\n        usernameField: mockUsername.name,\n        password: mockPassword.value,\n        passwordField: mockPassword.name,\n        formSubmitURL: formSubmitURL\n      });\n    },\n\n    /*\n     * _fillform\n     *\n     * Fill the form with login information if we can find it. This will find\n     * an array of logins if not given any, otherwise it will use the logins\n     * passed in. The logins are returned so they can be reused for\n     * optimization. Success of action is also returned in format\n     * [success, foundLogins].\n     *\n     * - autofillForm denotes if we should fill the form in automatically\n     * - ignoreAutocomplete denotes if we should ignore autocomplete=off\n     *     attributes\n     * - userTriggered is an indication of whether this filling was triggered by\n     *     the user\n     * - foundLogins is an array of nsILoginInfo for optimization\n     */\n    _fillForm: function _fillForm(form, autofillForm, ignoreAutocomplete, clobberPassword, userTriggered, foundLogins) {\n      // Heuristically determine what the user/pass fields are\n      // We do this before checking to see if logins are stored,\n      // so that the user isn\'t prompted for a master password\n      // without need.\n      var fields = this._getFormFields(form, false);\n      var usernameField = fields[0];\n      var passwordField = fields[1];\n\n      // Need a valid password field to do anything.\n      if (passwordField == null) return [false, foundLogins];\n\n      // If the password field is disabled or read-only, there\'s nothing to do.\n      if (passwordField.disabled || passwordField.readOnly) {\n        log("not filling form, password field disabled or read-only");\n        return [false, foundLogins];\n      }\n\n      // Discard logins which have username/password values that don\'t\n      // fit into the fields (as specified by the maxlength attribute).\n      // The user couldn\'t enter these values anyway, and it helps\n      // with sites that have an extra PIN to be entered (bug 391514)\n      var maxUsernameLen = Number.MAX_VALUE;\n      var maxPasswordLen = Number.MAX_VALUE;\n\n      // If attribute wasn\'t set, default is -1.\n      if (usernameField && usernameField.maxLength >= 0) maxUsernameLen = usernameField.maxLength;\n      if (passwordField.maxLength >= 0) maxPasswordLen = passwordField.maxLength;\n\n      var createLogin = function createLogin(login) {\n        return {\n          hostname: login.hostname,\n          formSubmitURL: login.formSubmitURL,\n          httpReal: login.httpRealm,\n          username: login.username,\n          password: login.password,\n          usernameField: login.usernameField,\n          passwordField: login.passwordField\n        };\n      };\n      foundLogins = map(foundLogins, createLogin);\n      var logins = foundLogins.filter(function (l) {\n        var fit = l.username.length <= maxUsernameLen && l.password.length <= maxPasswordLen;\n        if (!fit) log("Ignored", l.username, "login: won\'t fit");\n\n        return fit;\n      }, this);\n\n      // Nothing to do if we have no matching logins available.\n      if (logins.length == 0) return [false, foundLogins];\n\n      // The reason we didn\'t end up filling the form, if any.  We include\n      // this in the formInfo object we send with the passwordmgr-found-logins\n      // notification.  See the _notifyFoundLogins docs for possible values.\n      var didntFillReason = null;\n\n      // Attach autocomplete stuff to the username field, if we have\n      // one. This is normally used to select from multiple accounts,\n      // but even with one account we should refill if the user edits.\n      // if (usernameField)\n      //    formFillService.markAsLoginManagerField(usernameField);\n\n      // Don\'t clobber an existing password.\n      if (passwordField.value && !clobberPassword) {\n        didntFillReason = "existingPassword";\n        return [false, foundLogins];\n      }\n\n      // If the form has an autocomplete=off attribute in play, don\'t\n      // fill in the login automatically. We check this after attaching\n      // the autocomplete stuff to the username field, so the user can\n      // still manually select a login to be filled in.\n      var isFormDisabled = false;\n      if (!ignoreAutocomplete && (this._isAutocompleteDisabled(form) || this._isAutocompleteDisabled(usernameField) || this._isAutocompleteDisabled(passwordField))) {\n\n        isFormDisabled = true;\n        log("form not filled, has autocomplete=off");\n      }\n\n      // Variable such that we reduce code duplication and can be sure we\n      // should be firing notifications if and only if we can fill the form.\n      var selectedLogin = null;\n\n      if (usernameField && (usernameField.value || usernameField.disabled || usernameField.readOnly)) {\n        // If username was specified in the field, it\'s disabled or it\'s readOnly, only fill in the\n        // password if we find a matching login.\n        var username = usernameField.value.toLowerCase();\n\n        var matchingLogins = logins.filter(function (l) {\n          return l.username.toLowerCase() == username;\n        });\n        if (matchingLogins.length) {\n          // If there are multiple, and one matches case, use it\n          for (var i = 0; i < matchingLogins.length; i++) {\n            var l = matchingLogins[i];\n            if (l.username == usernameField.value) {\n              selectedLogin = l;\n            }\n          }\n          // Otherwise just use the first\n          if (!selectedLogin) {\n            selectedLogin = matchingLogins[0];\n          }\n        } else {\n          didntFillReason = "existingUsername";\n          log("Password not filled. None of the stored logins match the username already present.");\n        }\n      } else if (logins.length == 1) {\n        selectedLogin = logins[0];\n      } else {\n        // We have multiple logins. Handle a special case here, for sites\n        // which have a normal user+pass login *and* a password-only login\n        // (eg, a PIN). Prefer the login that matches the type of the form\n        // (user+pass or pass-only) when there\'s exactly one that matches.\n        var matchingLogins;\n        if (usernameField) matchingLogins = logins.filter(function (l) {\n          return l.username;\n        });else matchingLogins = logins.filter(function (l) {\n          return !l.username;\n        });\n\n        // We really don\'t want to type on phones, so we always autofill with something...\n        //if (matchingLogins.length == 1) {\n        selectedLogin = matchingLogins[0];\n        //} else {\n        //didntFillReason = "multipleLogins";\n        //log("Multiple logins for form, so not filling any.");\n        //}\n      }\n\n      var didFillForm = false;\n      if (selectedLogin && autofillForm && !isFormDisabled) {\n        // Fill the form\n        if (usernameField) {\n          // Don\'t modify the username field if it\'s disabled or readOnly so we preserve its case.\n          var disabledOrReadOnly = usernameField.disabled || usernameField.readOnly;\n\n          var userNameDiffers = selectedLogin.username != usernameField.value;\n          // Don\'t replace the username if it differs only in case, and the user triggered\n          // this autocomplete. We assume that if it was user-triggered the entered text\n          // is desired.\n          var userEnteredDifferentCase = userTriggered && userNameDiffers && usernameField.value.toLowerCase() == selectedLogin.username.toLowerCase();\n\n          if (!disabledOrReadOnly && !userEnteredDifferentCase && userNameDiffers) {\n            usernameField.value = selectedLogin.username;\n            dispatchKeyboardEvent(usernameField, "keydown", KEYCODE_ARROW_DOWN);\n            dispatchKeyboardEvent(usernameField, "keyup", KEYCODE_ARROW_DOWN);\n          }\n        }\n        if (passwordField.value != selectedLogin.password) {\n          passwordField.value = selectedLogin.password;\n          dispatchKeyboardEvent(passwordField, "keydown", KEYCODE_ARROW_DOWN);\n          dispatchKeyboardEvent(passwordField, "keyup", KEYCODE_ARROW_DOWN);\n        }\n        didFillForm = true;\n      } else if (selectedLogin && !autofillForm) {\n        // For when autofillForm is false, but we still have the information\n        // to fill a form, we notify observers.\n        didntFillReason = "noAutofillForms";\n        // Services.obs.notifyObservers(form, "passwordmgr-found-form", didntFillReason);\n        log("autofillForms=false but form can be filled; notified observers");\n      } else if (selectedLogin && isFormDisabled) {\n        // For when autocomplete is off, but we still have the information\n        // to fill a form, we notify observers.\n        didntFillReason = "autocompleteOff";\n        // Services.obs.notifyObservers(form, "passwordmgr-found-form", didntFillReason);\n        log("autocomplete=off but form can be filled; notified observers");\n      }\n\n      // this._notifyFoundLogins(didntFillReason, usernameField, passwordField, foundLogins, selectedLogin);\n      return [didFillForm, foundLogins];\n    }\n  };\n\n  var LoginUtils = {\n    /*\n     * _getPasswordOrigin\n     *\n     * Get the parts of the URL we want for identification.\n     */\n    _getPasswordOrigin: function _getPasswordOrigin(uriString, allowJS) {\n      // All of this logic is moved to swift (so that we don\'t need a uri parser here)\n      return uriString;\n    },\n\n    _getActionOrigin: function _getActionOrigin(form) {\n      var uriString = form.action;\n\n      // A blank or missing action submits to where it came from.\n      if (uriString == "") uriString = form.baseURI; // ala bug 297761\n\n      return this._getPasswordOrigin(uriString, true);\n    }\n  };\n\n  function onBlur(event) {\n    LoginManagerContent.onUsernameInput(event);\n  }\n\n  var documentBody = document.body;\n  var observer = new MutationObserver(function (mutations) {\n    for (var idx = 0; idx < mutations.length; ++idx) {\n      findForms(mutations[idx].addedNodes);\n    }\n  });\n\n  function findForms(nodes) {\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      if (node.nodeName === "FORM") {\n        findLogins(node);\n      } else if (node.hasChildNodes()) {\n        findForms(node.childNodes);\n      }\n    }\n    return false;\n  }\n\n  observer.observe(documentBody, { attributes: false, childList: true, characterData: false, subtree: true });\n\n  function findLogins(form) {\n    try {\n      LoginManagerContent._asyncFindLogins(form, {}).then(function (res) {\n        LoginManagerContent.loginsFound(res.form, res.loginsFound);\n      }).then(null, log);\n    } catch (ex) {\n      // Eat errors to avoid leaking them to the page\n      log(ex);\n    }\n  }\n\n  window.addEventListener("load", function (event) {\n    for (var i = 0; i < document.forms.length; i++) {\n      findLogins(document.forms[i]);\n    }\n  });\n\n  window.addEventListener("submit", function (event) {\n    try {\n      LoginManagerContent._onFormSubmit(event.target);\n    } catch (ex) {\n      // Eat errors to avoid leaking them to the page\n      log(ex);\n    }\n  });\n\n  function LoginInjector() {\n    this.inject = function (msg) {\n      try {\n        LoginManagerContent.receiveMessage(msg);\n      } catch (ex) {\n        // Eat errors to avoid leaking them to the page\n        // alert(ex);\n      }\n    };\n  }\n\n  Object.defineProperty(window.__firefox__, "logins", {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: Object.freeze(new LoginInjector())\n  });\n\n  function map(array, callback) {\n    var T, A, k;\n\n    if (array == null) {\n      throw new TypeError("Array is null or not defined");\n    }\n\n    var O = Object(array);\n    var len = O.length >>> 0;\n    if (typeof callback !== "function") {\n      throw new TypeError(callback + " is not a function");\n    }\n    if (arguments.length > 1) {\n      T = array;\n    }\n    A = new Array(len);\n    k = 0;\n    while (k < len) {\n      var kValue, mappedValue;\n      if (k in O) {\n        kValue = O[k];\n        mappedValue = callback.call(T, kValue, k, O);\n        A[k] = mappedValue;\n      }\n      k++;\n    }\n    return A;\n  };\n\n  function dispatchKeyboardEvent(element, eventName, keyCode) {\n    var event = document.createEvent("KeyboardEvent");\n    event.initKeyboardEvent(eventName, true, true, window, 0, 0, 0, 0, 0, keyCode);\n    element.dispatchEvent(event);\n  }\n});\n\n//# sourceURL=webpack:///./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/LoginsHelper.js?')},"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/PrintHandler.js":
/*!*****************************************************************************************!*\
  !*** ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/PrintHandler.js ***!
  \*****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('/* vim: set ts=2 sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// Ensure this module only gets included once. This is\n// required for user scripts injected into all frames.\n\nwindow.__firefox__.includeOnce("PrintHandler", function () {\n  window.print = function () {\n    webkit.messageHandlers.printHandler.postMessage({});\n  };\n});\n\n//# sourceURL=webpack:///./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/PrintHandler.js?')},"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/__firefox__.js":
/*!****************************************************************************************!*\
  !*** ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/__firefox__.js ***!
  \****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/* vim: set ts=2 sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\nif (!window.__firefox__) {\n  Object.defineProperty(window, \"__firefox__\", {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: {\n      userScripts: {},\n      includeOnce: function includeOnce(userScript, initializer) {\n        if (!__firefox__.userScripts[userScript]) {\n          __firefox__.userScripts[userScript] = true;\n          if (typeof initializer === 'function') {\n            initializer();\n          }\n          return false;\n        }\n\n        return true;\n      }\n    }\n  });\n}\n\n//# sourceURL=webpack:///./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/__firefox__.js?")},1:
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/__firefox__.js ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/ContextMenu.js ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/DownloadHelper.js ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/FocusHelper.js ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/LoginsHelper.js ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/PrintHandler.js ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__(/*! ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/__firefox__.js */"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/__firefox__.js");\n__webpack_require__(/*! ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/ContextMenu.js */"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/ContextMenu.js");\n__webpack_require__(/*! ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/DownloadHelper.js */"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/DownloadHelper.js");\n__webpack_require__(/*! ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/FocusHelper.js */"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/FocusHelper.js");\n__webpack_require__(/*! ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/LoginsHelper.js */"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/LoginsHelper.js");\nmodule.exports = __webpack_require__(/*! ./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/PrintHandler.js */"./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/PrintHandler.js");\n\n\n//# sourceURL=webpack:///multi_./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/__firefox__.js_./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/ContextMenu.js_./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/DownloadHelper.js_./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/FocusHelper.js_./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/LoginsHelper.js_./Client/Frontend/UserContent/UserScripts/AllFrames/AtDocumentEnd/PrintHandler.js?')}});